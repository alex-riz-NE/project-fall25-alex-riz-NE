const o=[];o.push("SIGHUP","SIGINT","SIGTERM"),process.platform!=="win32"&&o.push("SIGALRM","SIGABRT","SIGVTALRM","SIGXCPU","SIGXFSZ","SIGUSR2","SIGTRAP","SIGSYS","SIGQUIT","SIGIOT"),process.platform==="linux"&&o.push("SIGIO","SIGPOLL","SIGPWR","SIGSTKFLT");const l=i=>!!i&&typeof i=="object"&&typeof i.removeListener=="function"&&typeof i.emit=="function"&&typeof i.reallyExit=="function"&&typeof i.listeners=="function"&&typeof i.kill=="function"&&typeof i.pid=="number"&&typeof i.on=="function",h=Symbol.for("signal-exit emitter"),a=globalThis,d=Object.defineProperty.bind(Object);class m{emitted={afterExit:!1,exit:!1};listeners={afterExit:[],exit:[]};count=0;id=Math.random();constructor(){if(a[h])return a[h];d(a,h,{value:this,writable:!1,enumerable:!1,configurable:!1})}on(t,e){this.listeners[t].push(e)}removeListener(t,e){const s=this.listeners[t],n=s.indexOf(e);n!==-1&&(n===0&&s.length===1?s.length=0:s.splice(n,1))}emit(t,e,s){if(this.emitted[t])return!1;this.emitted[t]=!0;let n=!1;for(const r of this.listeners[t])n=r(e,s)===!0||n;return t==="exit"&&(n=this.emit("afterExit",e,s)||n),n}}class c{}const p=i=>({onExit(t,e){return i.onExit(t,e)},load(){return i.load()},unload(){return i.unload()}});class S extends c{onExit(){return()=>{}}load(){}unload(){}}class I extends c{#r=f.platform==="win32"?"SIGINT":"SIGHUP";#e=new m;#t;#n;#o;#s={};#i=!1;constructor(t){super(),this.#t=t,this.#s={};for(const e of o)this.#s[e]=()=>{const s=this.#t.listeners(e);let{count:n}=this.#e;const r=t;if(typeof r.__signal_exit_emitter__=="object"&&typeof r.__signal_exit_emitter__.count=="number"&&(n+=r.__signal_exit_emitter__.count),s.length===n){this.unload();const u=this.#e.emit("exit",null,e),x=e==="SIGHUP"?this.#r:e;u||t.kill(t.pid,x)}};this.#o=t.reallyExit,this.#n=t.emit}onExit(t,e){if(!l(this.#t))return()=>{};this.#i===!1&&this.load();const s=e?.alwaysLast?"afterExit":"exit";return this.#e.on(s,t),()=>{this.#e.removeListener(s,t),this.#e.listeners.exit.length===0&&this.#e.listeners.afterExit.length===0&&this.unload()}}load(){if(!this.#i){this.#i=!0,this.#e.count+=1;for(const t of o)try{const e=this.#s[t];e&&this.#t.on(t,e)}catch{}this.#t.emit=(t,...e)=>this.#h(t,...e),this.#t.reallyExit=t=>this.#l(t)}}unload(){this.#i&&(this.#i=!1,o.forEach(t=>{const e=this.#s[t];if(!e)throw new Error("Listener not defined for signal: "+t);try{this.#t.removeListener(t,e)}catch{}}),this.#t.emit=this.#n,this.#t.reallyExit=this.#o,this.#e.count-=1)}#l(t){return l(this.#t)?(this.#t.exitCode=t||0,this.#e.emit("exit",this.#t.exitCode,null),this.#o.call(this.#t,this.#t.exitCode)):0}#h(t,...e){const s=this.#n;if(t==="exit"&&l(this.#t)){typeof e[0]=="number"&&(this.#t.exitCode=e[0]);const n=s.call(this.#t,t,...e);return this.#e.emit("exit",this.#t.exitCode,null),n}else return s.call(this.#t,t,...e)}}const f=globalThis.process,{onExit:y,load:G,unload:E}=p(l(f)?new I(f):new S);export{G as load,y as onExit,o as signals,E as unload};
