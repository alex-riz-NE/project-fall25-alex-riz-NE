import{isTokenEOF as c,TokenType as v,stringify as u,isToken as C,mirrorVariant as B,ParseError as g,isTokenComma as b,isTokenOpenParen as V,isTokenOpenCurly as J,isTokenOpenSquare as M,isTokenFunction as j,isTokenWhitespace as T,isTokenComment as E,mirrorVariantType as U,isTokenWhiteSpaceOrComment as S,isTokenCloseParen as z}from"../css-tokenizer@3.0.4/index.js";var a;function y(t){let e=t.slice();return(o,n,s)=>{let i=-1;for(let r=e.indexOf(n);r<e.length&&(i=o.indexOf(e[r]),i===-1||i<s);r++);return i===-1||i===s&&n===o[s]&&(i++,i>=o.length)?-1:(e=o.slice(),i)}}function m(t,e){const o=e[0];if(V(o)||J(o)||M(o)){const n=L(t,e);return{advance:n.advance,node:n.node}}if(j(o)){const n=I(t,e);return{advance:n.advance,node:n.node}}if(T(o)){const n=w(t,e);return{advance:n.advance,node:n.node}}if(E(o)){const n=q(t,e);return{advance:n.advance,node:n.node}}return{advance:1,node:new f(o)}}(function(t){t.Function="function",t.SimpleBlock="simple-block",t.Whitespace="whitespace",t.Comment="comment",t.Token="token"})(a||(a={}));class N{value=[];indexOf(e){return this.value.indexOf(e)}at(e){if(typeof e=="number")return e<0&&(e=this.value.length+e),this.value[e]}forEach(e,o){if(this.value.length===0)return;const n=y(this.value);let s=0;for(;s<this.value.length;){const i=this.value[s];let r;if(o&&(r={...o}),e({node:i,parent:this,state:r},s)===!1)return!1;if(s=n(this.value,i,s),s===-1)break}}walk(e,o){this.value.length!==0&&this.forEach((n,s)=>e(n,s)!==!1&&(!("walk"in n.node)||!this.value.includes(n.node)||n.node.walk(e,n.state)!==!1)&&void 0,o)}}class l extends N{type=a.Function;name;endToken;constructor(e,o,n){super(),this.name=e,this.endToken=o,this.value=n}getName(){return this.name[4].value}normalize(){c(this.endToken)&&(this.endToken=[v.CloseParen,")",-1,-1,void 0])}tokens(){return c(this.endToken)?[this.name,...this.value.flatMap(e=>e.tokens())]:[this.name,...this.value.flatMap(e=>e.tokens()),this.endToken]}toString(){const e=this.value.map(o=>C(o)?u(o):o.toString()).join("");return u(this.name)+e+u(this.endToken)}toJSON(){return{type:this.type,name:this.getName(),tokens:this.tokens(),value:this.value.map(e=>e.toJSON())}}isFunctionNode(){return l.isFunctionNode(this)}static isFunctionNode(e){return!!e&&e instanceof l&&e.type===a.Function}}function I(t,e){const o=[];let n=1;for(;;){const s=e[n];if(!s||c(s))return t.onParseError(new g("Unexpected EOF while consuming a function.",e[0][2],e[e.length-1][3],["5.4.9. Consume a function","Unexpected EOF"])),{advance:e.length,node:new l(e[0],s,o)};if(z(s))return{advance:n+1,node:new l(e[0],s,o)};if(S(s)){const r=F(t,e.slice(n));n+=r.advance,o.push(...r.nodes);continue}const i=m(t,e.slice(n));n+=i.advance,o.push(i.node)}}class h extends N{type=a.SimpleBlock;startToken;endToken;constructor(e,o,n){super(),this.startToken=e,this.endToken=o,this.value=n}normalize(){if(c(this.endToken)){const e=B(this.startToken);e&&(this.endToken=e)}}tokens(){return c(this.endToken)?[this.startToken,...this.value.flatMap(e=>e.tokens())]:[this.startToken,...this.value.flatMap(e=>e.tokens()),this.endToken]}toString(){const e=this.value.map(o=>C(o)?u(o):o.toString()).join("");return u(this.startToken)+e+u(this.endToken)}toJSON(){return{type:this.type,startToken:this.startToken,tokens:this.tokens(),value:this.value.map(e=>e.toJSON())}}isSimpleBlockNode(){return h.isSimpleBlockNode(this)}static isSimpleBlockNode(e){return!!e&&e instanceof h&&e.type===a.SimpleBlock}}function L(t,e){const o=U(e[0][0]);if(!o)throw new Error("Failed to parse, a mirror variant must exist for all block open tokens.");const n=[];let s=1;for(;;){const i=e[s];if(!i||c(i))return t.onParseError(new g("Unexpected EOF while consuming a simple block.",e[0][2],e[e.length-1][3],["5.4.8. Consume a simple block","Unexpected EOF"])),{advance:e.length,node:new h(e[0],i,n)};if(i[0]===o)return{advance:s+1,node:new h(e[0],i,n)};if(S(i)){const k=F(t,e.slice(s));s+=k.advance,n.push(...k.nodes);continue}const r=m(t,e.slice(s));s+=r.advance,n.push(r.node)}}class p{type=a.Whitespace;value;constructor(e){this.value=e}tokens(){return this.value}toString(){return u(...this.value)}toJSON(){return{type:this.type,tokens:this.tokens()}}isWhitespaceNode(){return p.isWhitespaceNode(this)}static isWhitespaceNode(e){return!!e&&e instanceof p&&e.type===a.Whitespace}}function w(t,e){let o=0;for(;;){const n=e[o];if(!T(n))return{advance:o,node:new p(e.slice(0,o))};o++}}class d{type=a.Comment;value;constructor(e){this.value=e}tokens(){return[this.value]}toString(){return u(this.value)}toJSON(){return{type:this.type,tokens:this.tokens()}}isCommentNode(){return d.isCommentNode(this)}static isCommentNode(e){return!!e&&e instanceof d&&e.type===a.Comment}}function q(t,e){return{advance:1,node:new d(e[0])}}function F(t,e){const o=[];let n=0;for(;;)if(T(e[n])){const s=w(0,e.slice(n));n+=s.advance,o.push(s.node)}else{if(!E(e[n]))return{advance:n,nodes:o};o.push(new d(e[n])),n++}}class f{type=a.Token;value;constructor(e){this.value=e}tokens(){return[this.value]}toString(){return this.value[1]}toJSON(){return{type:this.type,tokens:this.tokens()}}isTokenNode(){return f.isTokenNode(this)}static isTokenNode(e){return!!e&&e instanceof f&&e.type===a.Token}}function G(t,e){const o={onParseError:e?.onParseError??(()=>{})},n=[...t];c(n[n.length-1])&&n.push([v.EOF,"",n[n.length-1][2],n[n.length-1][3],void 0]);const s=m(o,n);if(c(n[Math.min(s.advance,n.length-1)]))return s.node;o.onParseError(new g("Expected EOF after parsing a component value.",t[0][2],t[t.length-1][3],["5.3.9. Parse a component value","Expected EOF"]))}function $(t,e){const o={onParseError:e?.onParseError??(()=>{})},n=[...t];c(n[n.length-1])&&n.push([v.EOF,"",n[n.length-1][2],n[n.length-1][3],void 0]);const s=[];let i=0;for(;;){if(!n[i]||c(n[i]))return s;const r=m(o,n.slice(i));s.push(r.node),i+=r.advance}}function D(t,e){const o={onParseError:e?.onParseError??(()=>{})},n=[...t];if(t.length===0)return[];c(n[n.length-1])&&n.push([v.EOF,"",n[n.length-1][2],n[n.length-1][3],void 0]);const s=[];let i=[],r=0;for(;;){if(!n[r]||c(n[r]))return i.length&&s.push(i),s;if(b(n[r])){s.push(i),i=[],r++;continue}const k=m(o,t.slice(r));i.push(k.node),r+=k.advance}}function H(t){const e=new Map;return t.walk(o=>{Array.isArray(o.node)?o.node.forEach(n=>{e.set(n,o.parent)}):e.set(o.node,o.parent)}),e}function x(t,e,o){if(t.length===0)return;const n=y(t);let s=0;for(;s<t.length;){const i=t[s];let r;if(o&&(r={...o}),e({node:i,parent:{value:t},state:r},s)===!1)return!1;if(s=n(t,i,s),s===-1)break}}function P(t,e,o){t.length!==0&&x(t,(n,s)=>e(n,s)!==!1&&(!("walk"in n.node)||!t.includes(n.node)||n.node.walk(e,n.state)!==!1)&&void 0,o)}function K(t,e){for(let o=0;o<t.length;o++)P(t[o],(n,s)=>{if(typeof s!="number")return;const i=e(n.node);i&&(Array.isArray(i)?n.parent.value.splice(s,1,...i):n.parent.value.splice(s,1,i))});return t}function Q(t){return t.map(e=>e.map(o=>u(...o.tokens())).join("")).join(",")}function R(t){return h.isSimpleBlockNode(t)}function X(t){return l.isFunctionNode(t)}function W(t){return p.isWhitespaceNode(t)}function A(t){return d.isCommentNode(t)}function Y(t){return W(t)||A(t)}function Z(t){return f.isTokenNode(t)}function O(t){if(Array.isArray(t)){const s=t[0];if(!s)return[0,0];const i=t[t.length-1]||s;return[O(s)[0],O(i)[1]]}const e=t.tokens(),o=e[0],n=e[e.length-1];return o&&n?[o[2],n[3]]:[0,0]}export{d as CommentNode,a as ComponentValueType,N as ContainerNodeBaseClass,l as FunctionNode,h as SimpleBlockNode,f as TokenNode,p as WhitespaceNode,x as forEach,H as gatherNodeAncestry,A as isCommentNode,X as isFunctionNode,R as isSimpleBlockNode,Z as isTokenNode,Y as isWhiteSpaceOrCommentNode,W as isWhitespaceNode,D as parseCommaSeparatedListOfComponentValues,G as parseComponentValue,$ as parseListOfComponentValues,K as replaceComponentValues,O as sourceIndices,Q as stringify,P as walk,y as walkerIndexGenerator};
