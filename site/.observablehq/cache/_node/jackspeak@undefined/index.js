import{inspect as M}from"node:util";import*as F from"util";import R from"../@isaacs/cliui@8.0.2/index.js";import{basename as z}from"node:path";const V=typeof process=="object"&&process&&typeof process.version=="string"?process.version:"v0.0.0",_=V.replace(/^v/,"").split(".").map(i=>parseInt(i,10)),[A=0,L=0]=_;let{parseArgs:T}=F;(!T||A<16||A===18&&L<11||A===16&&L<19)&&(T=(await import("../@pkgjs/parseargs@0.11.0/index.js")).parseArgs);const q=T,k=Math.min(process&&process.stdout&&process.stdout.columns||80,80),N=i=>(i-1)*2,P=(i,t)=>[i,t.replace(/[^a-zA-Z0-9]+/g," ")].join(" ").trim().toUpperCase().replace(/ /g,"_"),U=(i,t=`
`)=>{const e=typeof i=="string"?i:typeof i=="boolean"?i?"1":"0":typeof i=="number"?String(i):Array.isArray(i)?i.map(o=>U(o)).join(t):void 0;if(typeof e!="string")throw new Error(`could not serialize value to environment: ${JSON.stringify(i)}`);return e},W=(i,t,e,o=`
`)=>e?i?i.split(o).map(s=>W(s,t,!1)):[]:t==="string"?i:t==="boolean"?i==="1":+i.trim(),Z=i=>typeof i=="string"&&(i==="string"||i==="number"||i==="boolean"),E=(i,t)=>i===void 0||typeof i===t,O=(i,t)=>i===void 0||Array.isArray(i)&&i.every(e=>typeof e===t),S=(i,t)=>Array.isArray(i)?i.every(e=>S(e,t)):t.includes(i),j=i=>typeof i=="string"?"string":typeof i=="boolean"?"boolean":typeof i=="number"?"number":Array.isArray(i)?H([...new Set(i.map(t=>j(t)))])+"[]":`${i.type}${i.multiple?"[]":""}`,H=i=>i.length===1&&typeof i[0]=="string"?i[0]:`(${i.join("|")})`,c=(i,t,e)=>e?Array.isArray(i)?!i.some(o=>!c(o,t,!1)):!1:Array.isArray(i)?!1:typeof i===t,I=(i,t,e)=>!!i&&typeof i=="object"&&Z(i.type)&&i.type===t&&E(i.short,"string")&&E(i.description,"string")&&E(i.hint,"string")&&E(i.validate,"function")&&(i.type==="boolean"?i.validOptions===void 0:O(i.validOptions,i.type))&&(i.default===void 0||c(i.default,t,e))&&!!i.multiple===e;function K(i={}){const{default:t,validate:e,validOptions:o,...s}=i;if(t!==void 0&&!c(t,"number",!1))throw new TypeError("invalid default value",{cause:{found:t,wanted:"number"}});if(!O(o,"number"))throw new TypeError("invalid validOptions",{cause:{found:o,wanted:"number[]"}});return{...s,default:t,validate:e||void 0,validOptions:o,type:"number",multiple:!1}}function G(i={}){const{default:t,validate:e,validOptions:o,...s}=i;if(t!==void 0&&!c(t,"number",!0))throw new TypeError("invalid default value",{cause:{found:t,wanted:"number[]"}});if(!O(o,"number"))throw new TypeError("invalid validOptions",{cause:{found:o,wanted:"number[]"}});return{...s,default:t,validate:e||void 0,validOptions:o,type:"number",multiple:!0}}function Q(i={}){const{default:t,validate:e,validOptions:o,...s}=i;if(t!==void 0&&!c(t,"string",!1))throw new TypeError("invalid default value",{cause:{found:t,wanted:"string"}});if(!O(o,"string"))throw new TypeError("invalid validOptions",{cause:{found:o,wanted:"string[]"}});return{...s,default:t,validate:e||void 0,validOptions:o,type:"string",multiple:!1}}function X(i={}){const{default:t,validate:e,validOptions:o,...s}=i;if(t!==void 0&&!c(t,"string",!0))throw new TypeError("invalid default value",{cause:{found:t,wanted:"string[]"}});if(!O(o,"string"))throw new TypeError("invalid validOptions",{cause:{found:o,wanted:"string[]"}});return{...s,default:t,validate:e||void 0,validOptions:o,type:"string",multiple:!0}}function Y(i={}){const{hint:t,default:e,validate:o,...s}=i;if(delete s.validOptions,e!==void 0&&!c(e,"boolean",!1))throw new TypeError("invalid default value");const n=o||void 0;if(t!==void 0)throw new TypeError("cannot provide hint for flag");return{...s,default:e,validate:n,type:"boolean",multiple:!1}}function tt(i={}){const{hint:t,default:e,validate:o,...s}=i;if(delete s.validOptions,e!==void 0&&!c(e,"boolean",!0))throw new TypeError("invalid default value");const n=o||void 0;if(t!==void 0)throw new TypeError("cannot provide hint for flag list");return{...s,default:e,validate:n,type:"boolean",multiple:!0}}const et=i=>{const t={};for(const e in i){const o=i[e];if(!o)throw new Error("config must be an object: "+e);if(I(o,"number",!0))t[e]={type:"string",multiple:!0,default:o.default?.map(n=>String(n))};else if(I(o,"number",!1))t[e]={type:"string",multiple:!1,default:o.default===void 0?void 0:String(o.default)};else{const n=o;t[e]={type:n.type,multiple:!!n.multiple,default:n.default}}const s=t[e];typeof o.short=="string"&&(s.short=o.short),o.type==="boolean"&&!e.startsWith("no-")&&!i[`no-${e}`]&&(t[`no-${e}`]={type:"boolean",multiple:o.multiple})}return t},C=i=>i.type==="heading",D=i=>i.type==="description";class B{#t;#o;#i;#e=[];#r;#n;#p;#a;#l;constructor(t={}){this.#i=t,this.#p=t.allowPositionals!==!1,this.#r=this.#i.env===void 0?process.env:this.#i.env,this.#n=t.envPrefix,this.#t=Object.create(null),this.#o=Object.create(null)}setConfigValues(t,e=""){try{this.validate(t)}catch(o){const s=o;throw e&&s&&typeof s=="object"&&(s.cause&&typeof s.cause=="object"?Object.assign(s.cause,{path:e}):s.cause={path:e}),s}for(const[o,s]of Object.entries(t)){const n=this.#t[o];if(!n)throw new Error("unexpected field in config set: "+o,{cause:{found:o}});n.default=s}return this}parse(t=process.argv){this.loadEnvDefaults();const e=this.parseRaw(t);return this.applyDefaults(e),this.writeEnv(e),e}loadEnvDefaults(){if(this.#n)for(const[t,e]of Object.entries(this.#t)){const o=P(this.#n,t),s=this.#r[o];s!==void 0&&(e.default=W(s,e.type,!!e.multiple,e.delim))}}applyDefaults(t){for(const[e,o]of Object.entries(this.#t))o.default!==void 0&&!(e in t.values)&&(t.values[e]=o.default)}parseRaw(t){t===process.argv&&(t=t.slice(process._eval!==void 0?1:2));const e=et(this.#t),o=q({args:t,options:e,strict:!1,allowPositionals:this.#p,tokens:!0}),s={values:{},positionals:[]};for(const n of o.tokens)if(n.kind==="positional"){if(s.positionals.push(n.value),this.#i.stopAtPositional||this.#i.stopAtPositionalTest?.(n.value)){s.positionals.push(...t.slice(n.index+1));break}}else if(n.kind==="option"){let a;if(n.name.startsWith("no-")){const l=this.#t[n.name],p=n.name.substring(3),f=this.#t[p];f&&f.type==="boolean"&&(!l||l.type==="boolean"&&!!l.multiple==!!f.multiple)&&(a=!1,n.name=p)}const r=this.#t[n.name];if(!r)throw new Error(`Unknown option '${n.rawName}'. To specify a positional argument starting with a '-', place it at the end of the command after '--', as in '-- ${n.rawName}'`,{cause:{found:n.rawName+(n.value?`=${n.value}`:"")}});if(a===void 0)if(n.value===void 0){if(r.type!=="boolean")throw new Error(`No value provided for ${n.rawName}, expected ${r.type}`,{cause:{name:n.rawName,wanted:j(r)}});a=!0}else{if(r.type==="boolean")throw new Error(`Flag ${n.rawName} does not take a value, received '${n.value}'`,{cause:{found:n}});if(r.type==="string")a=n.value;else if(a=+n.value,a!==a)throw new Error(`Invalid value '${n.value}' provided for '${n.rawName}' option, expected number`,{cause:{name:n.rawName,found:n.value,wanted:"number"}})}if(r.multiple){const l=s.values,p=l[n.name]??[];l[n.name]=p,p.push(a)}else{const l=s.values;l[n.name]=a}}for(const[n,a]of Object.entries(s.values)){const r=this.#t[n]?.validate,l=this.#t[n]?.validOptions;let p;if(l&&!S(a,l)&&(p={name:n,found:a,validOptions:l}),r&&!r(a)&&(p=p||{name:n,found:a}),p)throw new Error(`Invalid value provided for --${n}: ${JSON.stringify(a)}`,{cause:p})}return s}#u(t,e,o=t){if(!t.startsWith("no-")||typeof e!="boolean")return;const s=t.substring(3);if(this.#u(s,e,o),this.#t[s]?.type==="boolean")throw new Error(`do not set '${o}', instead set '${s}' as desired.`,{cause:{found:o,wanted:s}})}validate(t){if(!t||typeof t!="object")throw new Error("Invalid config: not an object",{cause:{found:t}});const e=t;for(const o in t){const s=e[o];if(s===void 0)continue;this.#u(o,s);const n=this.#t[o];if(!n)throw new Error(`Unknown config option: ${o}`,{cause:{found:o}});if(!c(s,n.type,!!n.multiple))throw new Error(`Invalid value ${j(s)} for ${o}, expected ${j(n)}`,{cause:{name:o,found:s,wanted:j(n)}});let a;if(n.validOptions&&!S(s,n.validOptions)&&(a={name:o,found:s,validOptions:n.validOptions}),n.validate&&!n.validate(s)&&(a=a||{name:o,found:s}),a)throw new Error(`Invalid config value for ${o}: ${s}`,{cause:a})}}writeEnv(t){if(!(!this.#r||!this.#n))for(const[e,o]of Object.entries(t.values)){const s=this.#t[e];this.#r[P(this.#n,e)]=U(o,s?.delim)}}heading(t,e,{pre:o=!1}={}){return e===void 0&&(e=this.#e.some(s=>C(s))?2:1),this.#e.push({type:"heading",text:t,level:e,pre:o}),this}description(t,{pre:e}={}){return this.#e.push({type:"description",text:t,pre:e}),this}num(t){return this.#s(t,K)}numList(t){return this.#s(t,G)}opt(t){return this.#s(t,Q)}optList(t){return this.#s(t,X)}flag(t){return this.#s(t,Y)}flagList(t){return this.#s(t,tt)}addFields(t){const e=this;for(const[o,s]of Object.entries(t))this.#d(o,s),e.#e.push({type:"config",name:o,value:s});return Object.assign(e.#t,t),e}#s(t,e){const o=this;return Object.assign(o.#t,Object.fromEntries(Object.entries(t).map(([s,n])=>{this.#d(s,n);const a=e(n);return o.#e.push({type:"config",name:s,value:a}),[s,a]}))),o}#d(t,e){if(!/^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?$/.test(t))throw new TypeError(`Invalid option name: ${t}, must be '-' delimited ASCII alphanumeric`);if(this.#t[t])throw new TypeError(`Cannot redefine option ${e}`);if(this.#o[t])throw new TypeError(`Cannot redefine option ${t}, already in use for ${this.#o[t]}`);if(e.short){if(!/^[a-zA-Z0-9]$/.test(e.short))throw new TypeError(`Invalid ${t} short option: ${e.short}, must be 1 ASCII alphanumeric character`);if(this.#o[e.short])throw new TypeError(`Invalid ${t} short option: ${e.short}, already in use for ${this.#o[e.short]}`);this.#o[e.short]=t,this.#o[t]=t}}usage(){if(this.#a)return this.#a;let t=1;const e=R({width:k}),o=this.#e[0];let s=o?.type==="heading"?1:0;if(o?.type==="heading"&&e.div({padding:[0,0,0,0],text:g(o.text)}),e.div({padding:[0,0,0,0],text:"Usage:"}),this.#i.usage)e.div({text:this.#i.usage,padding:[0,0,0,2]});else{const l=z(String(process.argv[1])),p=[],f=[],v=[],y=[];for(const[u,h]of Object.entries(this.#t))h.short?h.type==="boolean"?p.push(h.short):f.push([h.short,h.hint||u]):h.type==="boolean"?v.push(u):y.push([u,h.hint||u]);const w=p.length?" -"+p.join(""):"",$=f.map(([u,h])=>` --${u}=<${h}>`).join(""),b=v.map(u=>` --${u}`).join(""),m=y.map(([u,h])=>` --${u}=<${h}>`).join(""),d=`${l}${w}${$}${b}${m}`.trim();e.div({text:d,padding:[0,0,0,2]})}e.div({padding:[0,0,0,0],text:""});const n=this.#e[s];if(n&&D(n)){const l=g(n.text,n.pre);s++,e.div({padding:[0,0,0,0],text:l}),e.div({padding:[0,0,0,0],text:""})}const{rows:a,maxWidth:r}=this.#f(s);for(const l of a)if(l.left){const p=N(Math.max(t,2));l.left.length>r-3?(e.div({text:l.left,padding:[0,0,0,p]}),e.div({text:l.text,padding:[0,0,0,r]})):e.div({text:l.left,padding:[0,1,0,p],width:r},{padding:[0,0,0,0],text:l.text}),l.skipLine&&e.div({padding:[0,0,0,0],text:""})}else if(C(l)){const{level:p}=l;t=p;const f=p<=2?1:0;e.div({...l,padding:[0,0,f,N(p)]})}else e.div({...l,padding:[0,0,1,N(t+1)]});return this.#a=e.toString()}usageMarkdown(){if(this.#l)return this.#l;const t=[];let e=1;const o=this.#e[0];let s=o?.type==="heading"?1:0;if(o?.type==="heading"&&t.push(`# ${J(o.text)}`),t.push("Usage:"),this.#i.usage)t.push(x(this.#i.usage,!0));else{const r=z(String(process.argv[1])),l=[],p=[],f=[],v=[];for(const[d,u]of Object.entries(this.#t))u.short?u.type==="boolean"?l.push(u.short):p.push([u.short,u.hint||d]):u.type==="boolean"?f.push(d):v.push([d,u.hint||d]);const y=l.length?" -"+l.join(""):"",w=p.map(([d,u])=>` --${d}=<${u}>`).join(""),$=f.map(d=>` --${d}`).join(""),b=v.map(([d,u])=>` --${d}=<${u}>`).join(""),m=`${r}${y}${w}${$}${b}`.trim();t.push(x(m,!0))}const n=this.#e[s];n&&D(n)&&(t.push(x(n.text,n.pre)),s++);const{rows:a}=this.#f(s);for(const r of a)if(r.left)t.push("#".repeat(e+1)+" "+J(r.left,!0)),r.text&&t.push(x(r.text));else if(C(r)){const{level:l}=r;e=l,t.push(`${"#".repeat(e)} ${J(r.text,r.pre)}`)}else t.push(x(r.text,!!r.pre));return this.#l=t.join(`

`)+`
`}#f(t){let e=Math.max(12,Math.min(26,Math.floor(k/3))),o=8,s;const n=[];for(const a of this.#e.slice(t)){if(a.type!=="config"){s?.type==="config"&&(s.skipLine=!0),s=void 0,a.text=g(a.text,!!a.pre),n.push(a);continue}const{value:r}=a,l=r.description||"",p=r.multiple?"Can be set multiple times":"",f=r.validOptions?.length?`Valid options:${r.validOptions.map(h=>` ${JSON.stringify(h)}`)}`:"",v=l.includes(`
`)?`

`:`
`,y=[f,p].join(v).trim(),w=(g(l)+v+y).trim(),$=r.hint||(r.type==="number"?"n":r.type==="string"?a.name:void 0),b=r.short?r.type==="boolean"?`-${r.short} `:`-${r.short}<${$}> `:"",m=r.type==="boolean"?`${b}--${a.name}`:`${b}--${a.name}=<${$}>`,d={text:w,left:m,type:"config"};w.length>k-e&&(d.skipLine=!0),s&&m.length>e&&(s.skipLine=!0),s=d;const u=m.length+4;u>o&&u<e&&(o=u),n.push(d)}return{rows:n,maxWidth:o}}toJSON(){return Object.fromEntries(Object.entries(this.#t).map(([t,e])=>[t,{type:e.type,...e.multiple?{multiple:!0}:{},...e.delim?{delim:e.delim}:{},...e.short?{short:e.short}:{},...e.description?{description:g(e.description)}:{},...e.validate?{validate:e.validate}:{},...e.validOptions?{validOptions:e.validOptions}:{},...e.default!==void 0?{default:e.default}:{},...e.hint?{hint:e.hint}:{}}]))}[M.custom](t,e){return`Jack ${M(this.toJSON(),e)}`}}const g=(i,t=!1)=>t?i.split(`
`).map(e=>`\u200B${e}`).join(`
`):i.split(/^\s*```\s*$/gm).map((e,o)=>{if(o%2===1){if(!e.trim())return"```\n```\n";const s=e.split(`
`);s.pop(),s.shift();const n=s.reduce((r,l)=>{const p=l.match(/^\s*/)?.[0]??"";return p.length?Math.min(p.length,r):r},1/0),a=isFinite(n)?n:0;return"\n```\n"+s.map(r=>`\u200B${r.substring(a)}`).join(`
`)+"\n```\n"}return e.replace(/([^\n])\n[ \t]*([^\n])/g,(s,n,a)=>/^[-*]/.test(a)?`${n}
${a}`:`${n} ${a}`).replace(/([^\n])[ \t]+([^\n])/g,"$1 $2").replace(/\n{3,}/g,`

`).replace(/\n[ \t]+/g,`
`).trim()}).join(`
`),x=(i,t=!1)=>{const e=g(i,t).replace(/\\/g,"\\\\");return t?`\`\`\`
${e.replace(/\u200b/g,"")}
\`\`\``:e.replace(/\n +/g,`
`).trim()},J=(i,t=!1)=>{const e=g(i,t).replace(/[\s\u200b]+/g," ").trim();return t?`\`${e}\``:e},it=(i={})=>new B(i);export{B as Jack,I as isConfigOption,Z as isConfigType,it as jack};
