import{EventEmitter as I}from"node:events";import Y from"node:stream";import{StringDecoder as Q}from"node:string_decoder";const q=typeof process=="object"&&process?process:{stdout:null,stderr:null},z=i=>!!i&&typeof i=="object"&&(i instanceof Z||i instanceof Y||F(i)||G(i)),F=i=>!!i&&typeof i=="object"&&i instanceof I&&typeof i.pipe=="function"&&i.pipe!==Y.Writable.prototype.pipe,G=i=>!!i&&typeof i=="object"&&i instanceof I&&typeof i.write=="function"&&typeof i.end=="function",p=Symbol("EOF"),b=Symbol("maybeEmitEnd"),y=Symbol("emittedEnd"),A=Symbol("emittingEnd"),v=Symbol("emittedError"),O=Symbol("closed"),H=Symbol("read"),P=Symbol("flush"),J=Symbol("flushChunk"),d=Symbol("encoding"),w=Symbol("decoder"),n=Symbol("flowing"),j=Symbol("paused"),S=Symbol("resume"),o=Symbol("buffer"),l=Symbol("pipes"),h=Symbol("bufferLength"),N=Symbol("bufferPush"),R=Symbol("bufferShift"),f=Symbol("objectMode"),r=Symbol("destroyed"),W=Symbol("error"),_=Symbol("emitData"),K=Symbol("emitEnd"),k=Symbol("emitEnd2"),m=Symbol("async"),V=Symbol("abort"),D=Symbol("aborted"),L=Symbol("signal"),g=Symbol("dataListeners"),u=Symbol("discarded"),x=i=>Promise.resolve().then(i),X=i=>i(),tt=i=>i==="end"||i==="finish"||i==="prefinish",et=i=>i instanceof ArrayBuffer||!!i&&typeof i=="object"&&i.constructor&&i.constructor.name==="ArrayBuffer"&&i.byteLength>=0,st=i=>!Buffer.isBuffer(i)&&ArrayBuffer.isView(i);class U{src;dest;opts;ondrain;constructor(t,e,s){this.src=t,this.dest=e,this.opts=s,this.ondrain=()=>t[S](),this.dest.on("drain",this.ondrain)}unpipe(){this.dest.removeListener("drain",this.ondrain)}proxyErrors(t){}end(){this.unpipe(),this.opts.end&&this.dest.end()}}class it extends U{unpipe(){this.src.removeListener("error",this.proxyErrors),super.unpipe()}constructor(t,e,s){super(t,e,s),this.proxyErrors=a=>e.emit("error",a),t.on("error",this.proxyErrors)}}const rt=i=>!!i.objectMode,nt=i=>!i.objectMode&&!!i.encoding&&i.encoding!=="buffer";class Z extends I{[n]=!1;[j]=!1;[l]=[];[o]=[];[f];[d];[m];[w];[p]=!1;[y]=!1;[A]=!1;[O]=!1;[v]=null;[h]=0;[r]=!1;[L];[D]=!1;[g]=0;[u]=!1;writable=!0;readable=!0;constructor(...t){const e=t[0]||{};if(super(),e.objectMode&&typeof e.encoding=="string")throw new TypeError("Encoding and objectMode may not be used together");rt(e)?(this[f]=!0,this[d]=null):nt(e)?(this[d]=e.encoding,this[f]=!1):(this[f]=!1,this[d]=null),this[m]=!!e.async,this[w]=this[d]?new Q(this[d]):null,e&&e.debugExposeBuffer===!0&&Object.defineProperty(this,"buffer",{get:()=>this[o]}),e&&e.debugExposePipes===!0&&Object.defineProperty(this,"pipes",{get:()=>this[l]});const{signal:s}=e;s&&(this[L]=s,s.aborted?this[V]():s.addEventListener("abort",()=>this[V]()))}get bufferLength(){return this[h]}get encoding(){return this[d]}set encoding(t){throw new Error("Encoding must be set at instantiation time")}setEncoding(t){throw new Error("Encoding must be set at instantiation time")}get objectMode(){return this[f]}set objectMode(t){throw new Error("objectMode must be set at instantiation time")}get async(){return this[m]}set async(t){this[m]=this[m]||!!t}[V](){this[D]=!0,this.emit("abort",this[L]?.reason),this.destroy(this[L]?.reason)}get aborted(){return this[D]}set aborted(t){}write(t,e,s){if(this[D])return!1;if(this[p])throw new Error("write after end");if(this[r])return this.emit("error",Object.assign(new Error("Cannot call write after a stream was destroyed"),{code:"ERR_STREAM_DESTROYED"})),!0;typeof e=="function"&&(s=e,e="utf8"),e||(e="utf8");const a=this[m]?x:X;if(!this[f]&&!Buffer.isBuffer(t)){if(st(t))t=Buffer.from(t.buffer,t.byteOffset,t.byteLength);else if(et(t))t=Buffer.from(t);else if(typeof t!="string")throw new Error("Non-contiguous data written to non-objectMode stream")}return this[f]?(this[n]&&this[h]!==0&&this[P](!0),this[n]?this.emit("data",t):this[N](t),this[h]!==0&&this.emit("readable"),s&&a(s),this[n]):t.length?(typeof t=="string"&&!(e===this[d]&&!this[w]?.lastNeed)&&(t=Buffer.from(t,e)),Buffer.isBuffer(t)&&this[d]&&(t=this[w].write(t)),this[n]&&this[h]!==0&&this[P](!0),this[n]?this.emit("data",t):this[N](t),this[h]!==0&&this.emit("readable"),s&&a(s),this[n]):(this[h]!==0&&this.emit("readable"),s&&a(s),this[n])}read(t){if(this[r])return null;if(this[u]=!1,this[h]===0||t===0||t&&t>this[h])return this[b](),null;this[f]&&(t=null),this[o].length>1&&!this[f]&&(this[o]=[this[d]?this[o].join(""):Buffer.concat(this[o],this[h])]);const e=this[H](t||null,this[o][0]);return this[b](),e}[H](t,e){if(this[f])this[R]();else{const s=e;t===s.length||t===null?this[R]():typeof s=="string"?(this[o][0]=s.slice(t),e=s.slice(0,t),this[h]-=t):(this[o][0]=s.subarray(t),e=s.subarray(0,t),this[h]-=t)}return this.emit("data",e),!this[o].length&&!this[p]&&this.emit("drain"),e}end(t,e,s){return typeof t=="function"&&(s=t,t=void 0),typeof e=="function"&&(s=e,e="utf8"),t!==void 0&&this.write(t,e),s&&this.once("end",s),this[p]=!0,this.writable=!1,(this[n]||!this[j])&&this[b](),this}[S](){this[r]||(!this[g]&&!this[l].length&&(this[u]=!0),this[j]=!1,this[n]=!0,this.emit("resume"),this[o].length?this[P]():this[p]?this[b]():this.emit("drain"))}resume(){return this[S]()}pause(){this[n]=!1,this[j]=!0,this[u]=!1}get destroyed(){return this[r]}get flowing(){return this[n]}get paused(){return this[j]}[N](t){this[f]?this[h]+=1:this[h]+=t.length,this[o].push(t)}[R](){return this[f]?this[h]-=1:this[h]-=this[o][0].length,this[o].shift()}[P](t=!1){do;while(this[J](this[R]())&&this[o].length);!t&&!this[o].length&&!this[p]&&this.emit("drain")}[J](t){return this.emit("data",t),this[n]}pipe(t,e){if(this[r])return t;this[u]=!1;const s=this[y];return e=e||{},t===q.stdout||t===q.stderr?e.end=!1:e.end=e.end!==!1,e.proxyErrors=!!e.proxyErrors,s?e.end&&t.end():(this[l].push(e.proxyErrors?new it(this,t,e):new U(this,t,e)),this[m]?x(()=>this[S]()):this[S]()),t}unpipe(t){const e=this[l].find(s=>s.dest===t);e&&(this[l].length===1?(this[n]&&this[g]===0&&(this[n]=!1),this[l]=[]):this[l].splice(this[l].indexOf(e),1),e.unpipe())}addListener(t,e){return this.on(t,e)}on(t,e){const s=super.on(t,e);if(t==="data")this[u]=!1,this[g]++,!this[l].length&&!this[n]&&this[S]();else if(t==="readable"&&this[h]!==0)super.emit("readable");else if(tt(t)&&this[y])super.emit(t),this.removeAllListeners(t);else if(t==="error"&&this[v]){const a=e;this[m]?x(()=>a.call(this,this[v])):a.call(this,this[v])}return s}removeListener(t,e){return this.off(t,e)}off(t,e){const s=super.off(t,e);return t==="data"&&(this[g]=this.listeners("data").length,this[g]===0&&!this[u]&&!this[l].length&&(this[n]=!1)),s}removeAllListeners(t){const e=super.removeAllListeners(t);return(t==="data"||t===void 0)&&(this[g]=0,!this[u]&&!this[l].length&&(this[n]=!1)),e}get emittedEnd(){return this[y]}[b](){!this[A]&&!this[y]&&!this[r]&&this[o].length===0&&this[p]&&(this[A]=!0,this.emit("end"),this.emit("prefinish"),this.emit("finish"),this[O]&&this.emit("close"),this[A]=!1)}emit(t,...e){const s=e[0];if(t!=="error"&&t!=="close"&&t!==r&&this[r])return!1;if(t==="data")return!this[f]&&!s?!1:this[m]?(x(()=>this[_](s)),!0):this[_](s);if(t==="end")return this[K]();if(t==="close"){if(this[O]=!0,!this[y]&&!this[r])return!1;const c=super.emit("close");return this.removeAllListeners("close"),c}else if(t==="error"){this[v]=s,super.emit(W,s);const c=!this[L]||this.listeners("error").length?super.emit("error",s):!1;return this[b](),c}else if(t==="resume"){const c=super.emit("resume");return this[b](),c}else if(t==="finish"||t==="prefinish"){const c=super.emit(t);return this.removeAllListeners(t),c}const a=super.emit(t,...e);return this[b](),a}[_](t){for(const s of this[l])s.dest.write(t)===!1&&this.pause();const e=this[u]?!1:super.emit("data",t);return this[b](),e}[K](){return this[y]?!1:(this[y]=!0,this.readable=!1,this[m]?(x(()=>this[k]()),!0):this[k]())}[k](){if(this[w]){const e=this[w].end();if(e){for(const s of this[l])s.dest.write(e);this[u]||super.emit("data",e)}}for(const e of this[l])e.end();const t=super.emit("end");return this.removeAllListeners("end"),t}async collect(){const t=Object.assign([],{dataLength:0});this[f]||(t.dataLength=0);const e=this.promise();return this.on("data",s=>{t.push(s),this[f]||(t.dataLength+=s.length)}),await e,t}async concat(){if(this[f])throw new Error("cannot concat in objectMode");const t=await this.collect();return this[d]?t.join(""):Buffer.concat(t,t.dataLength)}async promise(){return new Promise((t,e)=>{this.on(r,()=>e(new Error("stream destroyed"))),this.on("error",s=>e(s)),this.on("end",()=>t())})}[Symbol.asyncIterator](){this[u]=!1;let t=!1;const e=async()=>(this.pause(),t=!0,{value:void 0,done:!0});return{next:()=>{if(t)return e();const s=this.read();if(s!==null)return Promise.resolve({done:!1,value:s});if(this[p])return e();let a,c;const B=E=>{this.off("data",T),this.off("end",C),this.off(r,M),e(),c(E)},T=E=>{this.off("error",B),this.off("end",C),this.off(r,M),this.pause(),a({value:E,done:!!this[p]})},C=()=>{this.off("error",B),this.off("data",T),this.off(r,M),e(),a({done:!0,value:void 0})},M=()=>B(new Error("stream destroyed"));return new Promise((E,$)=>{c=$,a=E,this.once(r,M),this.once("error",B),this.once("end",C),this.once("data",T)})},throw:e,return:e,[Symbol.asyncIterator](){return this}}}[Symbol.iterator](){this[u]=!1;let t=!1;const e=()=>(this.pause(),this.off(W,e),this.off(r,e),this.off("end",e),t=!0,{done:!0,value:void 0}),s=()=>{if(t)return e();const a=this.read();return a===null?e():{done:!1,value:a}};return this.once("end",e),this.once(W,e),this.once(r,e),{next:s,throw:e,return:e,[Symbol.iterator](){return this}}}destroy(t){if(this[r])return t?this.emit("error",t):this.emit(r),this;this[r]=!0,this[u]=!0,this[o].length=0,this[h]=0;const e=this;return typeof e.close=="function"&&!this[O]&&e.close(),t?this.emit("error",t):this.emit(r),this}static get isStream(){return z}}export{Z as Minipass,F as isReadable,z as isStream,G as isWritable};
